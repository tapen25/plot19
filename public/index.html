<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Activity Recognition</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f4f4f4;
            color: #333;
        }
        #startButton {
            font-size: 1.5rem;
            padding: 20px 40px;
            border-radius: 10px;
            border: none;
            background-color: #007aff;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        #status {
            font-size: 1.2rem;
            margin-top: 20px;
            color: #555;
        }
        #result {
            font-size: 3rem;
            font-weight: bold;
            margin-top: 10px;
            color: #007aff;
            min-height: 3rem;
        }
    </style>
</head>
<body>
    <button id="startButton">計測を開始</button>
    <div id="status">センサーへのアクセスを許可してください</div>
    <div id="result">...</div>

    <script>
        // -----------------------------------------------------------------
        // ★★★ 1. 設定項目 ★★★
        // -----------------------------------------------------------------

        // あなたがRenderでデプロイしたAPIのURL（末尾の /predict を忘れずに）
        const API_URL = 'https://my-activity-predictor.onrender.com/predict'; 
        
        // データを収集する間隔 (ミリ秒)
        // 注意: センサーの更新頻度はデバイスに依存します
        const SENSOR_INTERVAL_MS = 50; 

        // 1回の予測で使用するサンプル数（＝バッファサイズ）
        // (例: 50ms * 20サンプル = 1000ms (1秒) 分のデータで1回予測)
        const BUFFER_SIZE = 20; 

        // -----------------------------------------------------------------
        // 以下、メインロジック
        // -----------------------------------------------------------------

        const startButton = document.getElementById('startButton');
        const statusEl = document.getElementById('status');
        const resultEl = document.getElementById('result');

        let sensorDataBuffer = []; // 生の加速度データを溜めるバッファ
        let isSensorRunning = false;
        let sensorInterval;

        // --- 1. センサーのパーミッションを要求 (iOS/iPadOSに必要) ---
        function requestSensorPermission() {
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                // iOS 13+ の Safari
                DeviceMotionEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            startSensor();
                        } else {
                            statusEl.textContent = 'センサーへのアクセスが拒否されました';
                        }
                    })
                    .catch(error => {
                        statusEl.textContent = 'センサー許可エラー: ' + error.message;
                    });
            } else {
                // Android や iOS 13 未満のブラウザ
                startSensor();
            }
        }

        // --- 2. センサーのリスナーを開始 ---
        function startSensor() {
            statusEl.textContent = 'センサー待機中...';
            isSensorRunning = true;
            startButton.disabled = true;
            startButton.textContent = '計測中';

            // 'devicemotion' イベントリスナーを追加
            window.addEventListener('devicemotion', handleMotion);
        }
        
        // --- 3. センサーデータ（生）の取得とバッファリング ---
        function handleMotion(event) {
            if (!isSensorRunning) return;

            // 加速度データ (x, y, z) を取得 (重力加速度を含む)
            const acc = event.accelerationIncludingGravity;
            if (acc.x === null || acc.y === null || acc.z === null) {
                // センサーデータが取得できない場合
                statusEl.textContent = '加速度データを取得できません';
                return;
            }

            // 3軸の加速度から「合成加速度（大きさ）」を計算
            // sqrt(x^2 + y^2 + z^2)
            const magnitude = Math.sqrt(acc.x * acc.x + acc.y * acc.y + acc.z * acc.z);

            // バッファにデータを追加
            sensorDataBuffer.push(magnitude);

            // バッファが指定サイズに達したら、処理を実行
            if (sensorDataBuffer.length >= BUFFER_SIZE) {
                // バッファのコピーを渡して処理（非同期）
                processData(sensorDataBuffer.slice()); 
                
                // バッファをクリアして次の収集を開始
                sensorDataBuffer = []; 
            }
        }
        
        // --- 4. 特徴量の計算 (!!! 最重要 !!!) ---
        // sensorDataBuffer (加速度の大きさの配列) から5つの特徴量を計算
        function processData(data) {
            statusEl.textContent = '特徴量を計算中...';

            // 平均 (mean_acc)
            const mean = data.reduce((a, b) => a + b, 0) / data.length;
            
            // 標準偏差 (std_acc)
            const variance = data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / data.length;
            const std = Math.sqrt(variance);

            // 最大 (max_acc)
            const max = Math.max(...data);
            
            // 最小 (min_acc)
            const min = Math.min(...data);

            // エネルギー (energy)
            // ★警告: ここの 'energy' の計算方法は、
            // training_features.csv を作成した時と「完全に」一致させる必要があります。
            // ここでは一般的な「二乗平均」を使いますが、もし違う場合は修正してください。
            const energy = data.reduce((a, b) => a + (b * b), 0) / data.length;

            // 計算した特徴量をオブジェクトにまとめる
            const features = {
                mean_acc: mean,
                std_acc: std,
                max_acc: max,
                min_acc: min,
                energy: energy
            };

            // 5. APIサーバーに送信
            sendPrediction(features);
        }

        // --- 5. APIサーバーへ予測リクエストを送信 ---
        async function sendPrediction(features) {
            statusEl.textContent = 'APIサーバーへ送信中...';
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(features)
                });

                if (!response.ok) {
                    throw new Error(`APIサーバーエラー: ${response.status}`);
                }

                const result = await response.json();
                
                // 6. 結果の表示
                if (result.predicted_label) {
                    statusEl.textContent = '予測完了';
                    // (例: 'walk' -> 'Walk' のように大文字に)
                    const label = result.predicted_label;
                    resultEl.textContent = label.charAt(0).toUpperCase() + label.slice(1);
                } else if (result.error) {
                    throw new Error(result.error);
                }

            } catch (error) {
                statusEl.textContent = `予測エラー: ${error.message}`;
                resultEl.textContent = 'Error';
            }
        }

        // --- スタートボタンの処理 ---
        startButton.addEventListener('click', () => {
            if (!isSensorRunning) {
                requestSensorPermission();
            }
        });

    </script>
</body>
</html>