<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Activity Recognition (修正版)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background-color: #f4f4f4;
            color: #333;
        }
        #startButton {
            font-size: 1.5rem;
            padding: 20px 40px;
            border-radius: 10px;
            border: none;
            background-color: #007aff;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        #status {
            font-size: 1.2rem;
            margin-top: 20px;
            color: #555;
        }
        #result {
            font-size: 3rem;
            font-weight: bold;
            margin-top: 10px;
            color: #007aff;
            min-height: 3rem;
        }
    </style>
</head>
<body>
    <button id="startButton">計測を開始</button>
    <div id="status">センサーへのアクセスを許可してください</div>
    <div id="result">...</div>

    <script>
        // -----------------------------------------------------------------
        // ★★★ 1. 設定項目 ★★★
        // -----------------------------------------------------------------

        // あなたがRenderでデプロイしたAPIのURL（末尾の /predict を忘れずに）
        const API_URL = 'https://my-activity-predictor.onrender.com/predict'; 
        
        // データを収集する間隔 (ミリ秒)
        // 注意: センサーの更新頻度はデバイスに依存します
        // devicemotionイベントは通常固定のレートで発行されるため、
        // この設定は「processData」の呼び出し頻度制御（throttle）には使えません。
        // SENSOR_INTERVAL_MS は削除し、BUFFER_SIZEで制御します。

        // 1回の予測で使用するサンプル数（＝バッファサイズ）
        const BUFFER_SIZE = 20; 

        // -----------------------------------------------------------------
        // 以下、メインロジック
        // -----------------------------------------------------------------

        const startButton = document.getElementById('startButton');
        const statusEl = document.getElementById('status');
        const resultEl = document.getElementById('result');

        let sensorDataBuffer = []; // 生の加速度データを溜めるバッファ
        let isSensorRunning = false;
        // let sensorInterval; // <-- devicemotionを使うため不要に

        // --- 1. センサーのパーミッションを要求 (iOS/iPadOSに必要) ---
        function requestSensorPermission() {
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                // iOS 13+ の Safari
                DeviceMotionEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            startSensor();
                        } else {
                            statusEl.textContent = 'センサーへのアクセスが拒否されました';
                        }
                    })
                    .catch(error => {
                        statusEl.textContent = 'センサー許可エラー: ' + error.message;
                    });
            } else {
                // Android や iOS 13 未満のブラウザ
                startSensor();
            }
        }

        // --- 2. センサーのリスナーを開始 ---
        function startSensor() {
            statusEl.textContent = 'センサー待機中...';
            isSensorRunning = true;
            startButton.disabled = true;
            startButton.textContent = '計測中';

            // 'devicemotion' イベントリスナーを追加
            window.addEventListener('devicemotion', handleMotion);
        }
        
        // --- 3. センサーデータ（生）の取得とバッファリング (★★★ 修正点 ★★★) ---
        function handleMotion(event) {
            if (!isSensorRunning) return;

            // ★★★ 修正点 ★★★
            // 「重力加速度を除く」加速度 (acc) を取得
            // (training_features.csv の基準に合わせるため)
            const acc = event.acceleration; 
            // const acc = event.accelerationIncludingGravity; // <-- 修正前 (重力含む)

            if (acc === null || acc.x === null || acc.y === null || acc.z === null) {
                statusEl.textContent = '加速度データ(重力除く)を取得できません';
                // (もしここで止まる場合、デバイスが event.acceleration をサポートしていません)
                return;
            }

            // 3軸の加速度から「合成加速度（大きさ）」を計算
            // sqrt(x^2 + y^2 + z^2)
            const magnitude = Math.sqrt(acc.x * acc.x + acc.y * acc.y + acc.z * acc.z);
            
            // 静止時のmagnitudeは 0 に近くなるはず

            // バッファにデータを追加
            sensorDataBuffer.push(magnitude);

            // バッファが指定サイズに達したら、処理を実行
            if (sensorDataBuffer.length >= BUFFER_SIZE) {
                // バッファのコピーを渡して処理（非同期）
                processData(sensorDataBuffer.slice()); 
                
                // バッファをクリアして次の収集を開始
                sensorDataBuffer = []; 
            }
        }
        
        // --- 4. 特徴量の計算 (!!! 最重要 !!!) ---
        function processData(data) {
            statusEl.textContent = '特徴量を計算中...';

            // --- ★★★ 警告: 以下の計算方法は、学習データ作成時と一致させること ★★★ ---

            const mean = data.reduce((a, b) => a + b, 0) / data.length;
            
            const variance = data.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / data.length;
            const std = Math.sqrt(variance);

            const max = Math.max(...data);
            const min = Math.min(...data);

            const energy = data.reduce((a, b) => a + (b * b), 0) / data.length;
            
            // --- ★★★ 修正点 ★★★ ---
            // app.py (改良版) は3つの特徴量 (std_acc, min_acc, energy) を期待している
            // 5つすべて送っても app.py 側で抽出してくれるが、
            // 送信データ量を減らすため、必要なものだけ送る
            const features = {
                std_acc: std,
                min_acc: min,
                energy: energy
                
                // 以下は app.py (改良版) では使われない
                // mean_acc: mean, 
                // max_acc: max
            };
            
            // (もし app.py が古いモデル(5特徴量)を使っている場合は、
            //  上記のコメントアウトを外して5つ送る必要があります)

            // 5. APIサーバーに送信
            sendPrediction(features);
        }

        // --- 5. APIサーバーへ予測リクエストを送信 ---
        async function sendPrediction(features) {
            statusEl.textContent = 'APIサーバーへ送信中...';
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(features)
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: `APIサーバーエラー: ${response.status}` }));
                    throw new Error(errorData.error || `APIサーバーエラー: ${response.status}`);
                }

                const result = await response.json();
                
                // 6. 結果の表示
                if (result.predicted_label) {
                    statusEl.textContent = '予測完了';
                    const label = result.predicted_label;
                    
                    // 結果に応じて色とテキストを変更
                    let color = '#007aff'; // default (blue)
                    let text = label.charAt(0).toUpperCase() + label.slice(1);

                    if (label === 'stay') {
                        color = '#34C759'; // Green
                        text = 'Stay (静止)';
                    } else if (label === 'walk') {
                        color = '#007aff'; // Blue
                        text = 'Walk (歩行)';
                    } else if (label === 'jog') {
                        color = '#FF3B30'; // Red
                        text = 'Jog (ジョギング)';
                    }
                    
                    resultEl.textContent = text;
                    resultEl.style.color = color;

                } else if (result.error) {
                    throw new Error(result.error);
                }

            } catch (error) {
                statusEl.textContent = `予測エラー: ${error.message}`;
                resultEl.textContent = 'Error';
                resultEl.style.color = '#FF3B30'; // Red
            }
        }

        // --- スタートボタンの処理 ---
        startButton.addEventListener('click', () => {
            if (!isSensorRunning) {
                requestSensorPermission();
            }
        });

    </script>
</body>
</html>